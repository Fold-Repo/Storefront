# API Integration & Data Injection Guide

This guide explains how to consume external APIs (like your backend or a third-party service) and inject that data into the Fold storefront auto-populated placeholders.

## ðŸ— Architecture Overview

The Fold storefront uses a two-step process for dynamic content:
1.  **Fetching**: Data is fetched server-side in `app/storefront/[[...path]]/page.tsx` within the `fetchDynamicDataForPage` function.
2.  **Injection**: The fetched data is passed to `injectDynamicData` (from `lib/dataInjector.ts`), which replaces `{{placeholders}}` in the HTML with actual content.

---

## ðŸš€ Action Steps: Implementing FakeStoreAPI

If you want to test your storefront with real data before connecting your actual backend, follow these steps to use **FakeStoreAPI**.

### Step 1: Identify the Integration Point
Open `app/storefront/[[...path]]/page.tsx`. This file contains all the skeleton functions for data fetching (e.g., `fetchProducts`, `fetchFeaturedProducts`).

### Step 2: Implement the API Fetcher
Modify the `fetchProducts` function to call the External API.

```typescript
// Replace the existing fetchProducts helper in page.tsx
async function fetchProducts(storefrontId: string, filters?: { category?: string }) {
  try {
    // 1. Determine the URL (handling categories if needed)
    const url = filters?.category 
      ? `https://fakestoreapi.com/products/category/${filters.category}`
      : 'https://fakestoreapi.com/products';

    // 2. Fetch the data
    const response = await fetch(url);
    const data = await response.json();

    // 3. Map FakeStoreAPI data to Fold's expected format
    return data.map((item: any) => ({
      id: item.id,
      name: item.title,
      price: item.price.toFixed(2),
      description: item.description,
      image: item.image,
      category: item.category
    }));
  } catch (error) {
    console.error('Failed to fetch from FakeStoreAPI:', error);
    return [];
  }
}
```

### Step 3: Update Page-Specific Logic
Ensure the `fetchDynamicDataForPage` function is calling your new fetchers.

```typescript
// In fetchDynamicDataForPage inside page.tsx
case 'products':
  data.products = await fetchProducts(storefrontId, {});
  // Optional: Also fetch categories to populate sidebar/filters
  data.categories = await fetchCategories(storefrontId);
  break;
```

### Step 4: Verify Placeholders
Ensure your Storefront HTML (the one generated by AI or uploaded) contains the correct placeholders:
- `{{products}}`: This will be replaced by a grid of product cards.
- `{{product.name}}`, `{{product.price}}`: Use these on product detail pages.

---

## ðŸ›  Complete Implementation Example

Here is how your modified `fetchProducts` and `fetchCategories` should look using **FakeStoreAPI**.

### Fetching Products
```typescript
async function fetchProducts(storefrontId: string, filters?: { category?: string }) {
  const url = filters?.category 
    ? `https://fakestoreapi.com/products/category/${filters.category}`
    : 'https://fakestoreapi.com/products';
  
  const res = await fetch(url);
  const products = await res.json();
  
  return products.map((p: any) => ({
    id: p.id,
    name: p.title,
    price: p.price,
    image: p.image,
    description: p.description
  }));
}
```

### Fetching Categories
```typescript
async function fetchCategories(storefrontId: string) {
  const res = await fetch('https://fakestoreapi.com/products/categories');
  const categories = await res.json();
  
  return categories.map((cat: string) => ({
    id: cat,
    name: cat,
    slug: cat
  }));
}
```

---

## ðŸ’¡ Pro Tips
1.  **Data Mapping**: Always map your API response to the format expected by `lib/dataInjector.ts`. If your backend return `product_name`, rename it to `name` in the map function.
2.  **Caching**: Next.js automatically caches `fetch` calls. If you need real-time data, use `{ next: { revalidate: 0 } }` in your fetch options.
3.  **Error Handling**: Always return an empty array `[]` or `null` in `catch` blocks to prevent the entire page from crashing.
